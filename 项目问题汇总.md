## 第一个项目

1.  在实现过程中，你是如何将 CPU 分为六个子模块的？这些子模块分别是什么，并且各自负责哪些功能？

   - ALU（算术逻辑单元）：执行算术和逻辑操作。
   - RegFile（寄存器文件）：用于存储和读取寄存器中的数据。
   - Save & Load（存储和加载）：处理存储和加载指令。
   - Imm-Gen（立即数生成器）：生成指令中的立即数。
   - Data Path（数据通路）：负责指令的数据传输和处理。
   - Control Logic（控制逻辑）：根据指令类型和控制信号来控制 CPU 的操作。

2.  你在实现前三个模块后进行了单元测试，那你是如何测试这些模块的？可以分享一下你的测试方法和结果吗？
单元测试：以 alu 的 addi 功能为例。

*general answear* 首先为模块电路生成一些测试用例(in 和 out 文件)。电路从 in 文件读取输入，将输出写入 circ_out，与我们标准的out文件进行对比。

*more concrete* 每个输入都有一个独立的只读存储器（ROM），顺序储存了 in 文件的输入值。当开始测试电路时，每个输入选择ROM中的第一个值，并将结果输出到第一个测试样本中。随着时钟的下一个上升沿到来，计数器递增，选择ROM中的下一个值，然后重复这个过程。

3. 你是如何进行集成测试的？在测试过程中遇到了哪些挑战，你是如何解决的？

*general answear* 集成测试就是编写测试指令，让cpu运行这些指令。每运行一条指令，就将32个寄存器的值写入文件，与标准结果进行对比。

*more concrete* 利用 risc-v 模拟器 venus 可将测试代码文件转换为机器码，再将机器码存入 测试电路 的 ROM 中, 用于测试。作为参考的寄存器值也是模拟器生成的。

4.  在搭建数据通路、控制逻辑和立即数生成器时，你是按照什么顺序进行的？为什么选择从最简单的 I 型指令开始构建？

按照 I -> S -> L -> S -> U。因为 I 型指令只有 四个阶段 if id ex wb，不涉及mem， 比较简单。



5.  流水线设计是如何实现的？你是如何将 CPU 的运行过程划分为取指令和指令执行两个阶段的？

流水线是参考了 计算机组织与结构 软硬件接口组织 risc-v 版。因为cpu执行过程有五个阶段， 我要做二级流水，
很自然的就想到了把后四个阶段合为一个。至于为什么要按第一个阶段来分，是因为第一个阶段的数据 只有 pc 和 ins 是后续阶段需要使用的，我们只需要两个寄存器的值来保存即可。

由于在不同阶段有着不同的 pc 和 指令的值，我们只需要在两个阶段之间添加两个寄存器来保存这两个值就好了

6.  为了解决条件转移指令带来的控制冒险，你采取了什么措施？你能详细解释一下你是如何通过控制信号和无操作指令来消除冒险的吗？

采取的措施为：risc-v 的控制信号有一位 pcsel 是用来确定 下一个 pc 寄存器的值的。如果为 0，pc 正常+4. 如果为1，说明发生了跳转，需要插入一条 nop 控制令。所以，我只需利用 pcsel 和 多路选择器，来选择 nop 和 instrucion 即可

## 第二个项目

1.  你能详细介绍一下你为 XV6 增加的 backtrace 和 sysinfo 系统调用吗？它们的功能是什么，如何提升了系统的调试和监控效果？

backtrace 能够打印程序出错时，之前的函数调用情况（打印地址）。配合 addr2line 命令，我们可以找出函数所在的文件和行数
sysinfo 能够打印目前系统目前空闲的空间大小和正在运行的cpu核心数量。

1.  在实现页表的访问检测功能时，你是如何实现的？给定起始和终止地址后，XV6 是如何找出在这段地址空间上访问过的页表？

首先对起始地址做向下舍入处理。(一定是 4096的整数倍)。 在进程对应的 pagetable 中查找 起始地址对应的 pte,
如果pte 的 访问标志位被置1，那么就说明这个页表被访问了。判断完后 地址 += 4096 重复上述过程，直到超过终止地址


2.  你为 XV6 添加的时钟中断是如何工作的？它是如何帮助调试计算密集型程序的设计的？在终端上打印进程占用资源情况是通过哪种方式实现的？

- 首先需要知道的是，每过一个 tick, 硬件会强制 xv6 进入一个 timer-interrupt, 就是利用这个特性，来实现的用户态
中断。
- 就实现来说
    - 为进程添加 tick 数据域，用来存储倒计时的时间
    - 添加两个系统调用 sigalarm (设置 tick 的值)， 和 sigreturn (从中断处理函数返回原来的代码)
    - 当发生timer-interrupt 时，将 tick 字段减1， 如果 tick 字段为0， 发生中断。
    详细过程：保存断电，设置 pc 的值为 中断处理函数的指针。
    - 中断处理函数执行 sigreturn 结束，恢复现场，继续中断前执行的代码。


为每一个进程设置一个timer 字段。当执行sigalarm 系统调用后，设置进程timer 的值，开始倒计时。每过一个 tick, xv6会强制进入timer interrupt, 在这个异常处理快里，我们递减 进程 timer 的值，如果 timer 的值 为0， 我们保存断点信息，让后将 pc 的值替换为 sig_alarm系统调用, 再回复断点，恢复进程执行状态。

3. 你是怎么实现 copy-on-write 机制的
   - 在创建子进程的页表时，将子进程的虚拟页映射到父进程的物理页，并修改标志位为可读。
   - 添加缺页中断处理，出现缺页错误时，为子进程分新的物理空间，并修改页表，这是标志位为可写。
   - 添加计数器，统计每一个物理页的引用次数，当且仅当这个物理页的引用次数为0，他才能被回收。

4.  页表的访问信息是如何为垃圾回收器提供参考的？你能解释一下它如何提升系统运行的效率吗？

通过分析页表的访问模式，垃圾回收器可以确定哪些页表项是被频繁访问的，哪些页表项可能是冗余的或者已经不再需要的。根据这些信息，垃圾回收器可以更有效地管理内存资源，减少内存碎片和提升系统性能。

5.  在增强 XV6 操作系统的过程中，你遇到了哪些挑战？如何解决这些挑战？

不懂如何调试 xv6: 查阅文档，查阅手册。了解了 gdb 的常用命令，了解 gdb 会自动加载 .gdbinit file
遇到过 kernel panic问题, 设置断电，一步步调试。

最难调试的bug。在为xv6 实现写时复制的功能时，测试发现总会有内存泄漏的现象，也就是当进程结束时，有页面没能正常释放。
查手册发现，这是因为更改计数器的时候没有加锁导致的。因为不同进程可能会引用相同的物理页。如果恰好这些进程在同一个时间
对引用进行操作，那么会出现争用 (race condition) 的情况，导致引用数出错，不能正常回收。

6. xv6 添加系统调用的详细过程是什么？

	- 首先在 user.h 文件中添加系统调用对应的用户态函数声明。
	- xv6 有一个 perl 脚本，自动为 user.h 里的函数生成汇编代码。
		- 这个汇编代码的作用就是 就是将 调用的 syscall 编号存入 a7, 然后执行 ecall 指令
	- 执行完 ecall 指令后，就会进入用户中断处理函数，用户中断处理函数会调用 syscall 函数
	- syscall 函数会根据 a7 的值，执行对应的系统调用。


## 第三个项目

1.  采用了哪种编程语言进行开发？

kotlin 

2.  MVVM架构是什么？有何优点？

MVVM即Model-View-ViewModel
可以将ViewMode看作是Model和View的连接桥，
View可以通过事件绑定Model，
Model可以通过数据绑定View，
通过ViewMode可以实现数据和视图的完全分离。

