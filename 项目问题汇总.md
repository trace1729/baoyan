## 第一个项目

1.  在实现过程中，你是如何将 CPU 分为六个子模块的？这些子模块分别是什么，并且各自负责哪些功能？
   - ALU（算术逻辑单元）：执行算术和逻辑操作。
   - RegFile（寄存器文件）：用于存储和读取寄存器中的数据。
   - Save & Load（存储和加载）：处理存储和加载指令。
   - Imm-Gen（立即数生成器）：生成指令中的立即数。
   - Data Path（数据通路）：负责指令的数据传输和处理。
   - Control Logic（控制逻辑）：根据指令类型和控制信号来控制 CPU 的操作。
2.  你在实现前三个模块后进行了单元测试，那你是如何测试这些模块的？可以分享一下你的测试方法和结果吗？
单元测试：以 alu 的 addi 功能为例。

测试策略很简单，我们将每个电路组件视为黑盒，类似于一个函数，它有输入和输出。在我构建的单元测试电路中，每个输入都有一个独立的只读存储器（ROM），用于存储测试值。当开始测试电路时，每个输入选择ROM中的第一个值，并将结果输出到第一个测试样本中。随着时钟的下一个上升沿到来，计数器递增，选择ROM中的下一个值，然后重复这个过程。使用Logisim可以将输出写入文件，我们可以使用bash脚本将其与参考结果进行比较。

3.  在搭建数据通路、控制逻辑和立即数生成器时，你是按照什么顺序进行的？为什么选择从最简单的 I 型指令开始构建？

按照 I -> S -> L -> S -> U。因为 I 型指令只有 四个阶段 if id ex wb，不涉及mem， 比较简单。

你是如何进行集成测试的？在测试过程中遇到了哪些挑战，你是如何解决的？

首先编写用于测试的 risc-v 汇编代码 (可以不止一条指令)。利用 venus 将汇编代码转化为 机器码，将机器码存到 Logisim 的 ROM 中，作为测试数据。用我们制作好的cpu，运行存放rom中的指令, 每运行一条指令，就将此时32个寄存器的值打印到文件中，与 venus 的输出进行对比。


3.  流水线设计是如何实现的？你是如何将 CPU 的运行过程划分为取指令和指令执行两个阶段的？

流水线是参考了 计算机组织与结构 软硬件接口组织 risc-v 版。因为cpu执行过程有五个阶段， 我要做二级流水，
很自然的就想到了把后四个阶段合为一个。至于为什么要按第一个阶段来分，是因为第一个阶段的数据 只有 pc 和 ins 是后续阶段需要使用的，我们只需要两个寄存器的值来保存即可。

由于在不同阶段有着不同的 pc 和 指令的值，我们只需要在两个阶段之间添加两个寄存器来保存这两个值就好了

1.  为了解决条件转移指令带来的控制冒险，你采取了什么措施？你能详细解释一下你是如何通过控制信号和无操作指令来消除冒险的吗？

采取的措施为：risc-v 的控制信号有一位 pcsel 是用来确定 下一个 pc 寄存器的值的。如果为 0，pc 正常+4. 如果为1，说明发生了跳转，需要插入一条 nop 控制令。所以，我只需利用 pcsel 和 多路选择器，来选择 nop 和 instrucion 即可

## 第二个项目

1.  你能详细介绍一下你为 XV6 增加的 backtrace 和 sysinfo 系统调用吗？它们的功能是什么，如何提升了系统的调试和监控效果？

backtrace 能够打印程序出错时，之前的函数调用情况（打印地址）。配合 addr2line 命令，我们可以找出函数所在的文件和行数
sysinfo 能够打印目前系统目前空闲的空间大小和正在运行的cpu核心数量。

1.  在实现页表的访问检测功能时，你是如何实现的？给定起始和终止地址后，XV6 是如何找出在这段地址空间上访问过的页表？

首先对起始地址做向下舍入处理。(一定是 4096的整数倍)。 在进程对应的 pagetable 中查找 起始地址对应的 pte,
如果pte 的 访问标志位被置1，那么就说明这个页表被访问了。判断完后 地址 += 4096 重复上述过程，直到超过终止地址

1.  页表的访问信息是如何为垃圾回收器提供参考的？你能解释一下它如何提升系统运行的效率吗？

通过分析页表的访问模式，垃圾回收器可以确定哪些页表项是被频繁访问的，哪些页表项可能是冗余的或者已经不再需要的。根据这些信息，垃圾回收器可以更有效地管理内存资源，减少内存碎片和提升系统性能。

1.  你为 XV6 添加的时钟中断是如何工作的？它是如何帮助调试计算密集型程序的设计的？在终端上打印进程占用资源情况是通过哪种方式实现的？

- 首先需要知道的是，每过一个 tick, 硬件会强制 xv6 进入一个 timer-interrupt, 就是利用这个特性，来实现的用户态
中断。
- 就实现来说
    - 为进程添加 tick 数据域，用来存储倒计时的时间
    - 添加两个系统调用 sigalarm (设置 tick 的值)， 和 sigreturn (从中断处理函数返回原来的代码)
    - 当发生timer-interrupt 时，将 tick 字段减一， 如果 tick 字段为0， 发生中断。
    详细过程：保存断电，设置 pc 的值为 中断处理函数的指针。
    - 中断处理函数执行 sigreturn 结束，恢复现场，继续中断前执行的代码。


为每一个进程设置一个timer 字段。当执行sigalarm 系统调用后，设置进程timer 的值，开始倒计时。每过一个 tick, xv6会强制进入timer interrupt, 在这个异常处理快里，我们递减 进程 timer 的值，如果 timer 的值 为0， 我们保存断点信息，让后将 pc 的值替换为 sig_alarm系统调用, 再回复断点，恢复进程执行状态。

1.  在增强 XV6 操作系统的过程中，你遇到了哪些挑战？如何解决这些挑战？

不懂如何调试 xv6: 查阅文档，查阅手册。了解了 gdb 的常用命令，了解 gdb 会自动加载 .gdbinit file
遇到过 kernel panic问题, 设置断电，一步步调试。

1.  通过实现这些新功能和性能优化，你对操作系统有了更深入的理解。你能分享一下你在这个项目中学到了哪些关键的系统编程技能和知识？

深入理解了 操作系统执行系统调用的过程，执行中断的过程。

1. xv6 添加系统调用的详细过程是什么？

- 首先在 user.h 文件中添加系统调用对应的用户态函数声明。
- xv6 有一个 pl 脚本，自动为 user.h 里的函数生成汇编代码。
    - 这个汇编代码的作用就是 就是将 调用的 syscall 编号存入 a7, 然后执行 ecall 指令
- 执行完 ecall 指令后，就会进入用户中断处理函数，用户中断处理函数会调用 syscall 函数
- syscall 函数会根据 a7 的值，执行对应的系统调用。


## 第三个项目

1.  采用了哪种编程语言进行开发？

kotlin 

2.  MVVM架构是什么？有何优点？

MVVM即Model-View-ViewModel
可以将ViewMode看作是Model和View的连接桥，View可以通过事件绑定Model，Model可以通过数据绑定View，通过ViewMode可以实现数据和视图的完全分离

1.双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化,能很好的做到数据一致性。

2.View的功能进一步的强化，具有控制的部分功能。

3.UI和逻辑的开发解耦。

3.  Navigation组件是如何实现页面导航的？Navhost有何作用？

4.  爬虫服务是如何部署在服务器上的？

使用 fastapi 框架，可以很简单在服务器上的端口搭建service。app 向这个端口发送请求，服务器上py脚本读取请求
向酷我音乐网站爬取音乐信息，再返回给app。

5.  ExoPlayer是什么？怎样解析音乐数据进行播放？

一个 Android 的播放组件库, 根据服务器返回的url 播放音乐

6.  Room组件和Datastore组件各自的作用是什么？为什么要选择它们来储存用户信息？

Room 存 用户的账号密码
DataStore 存 个人偏好。
因为是方插件 性能官好

7.  声明式编程与式编程相比，有何优势？

代码更加简洁， 直接在kotlin就能实现界面定制，不需要单独写xml 文件。
自动实现 状态绑定，当ui中某一个数据发生了变化，android 会自动重新渲染界面

8.  如何在程序中实现低层次的代码复用？对性能有何提升？

kotlin 支持函数编程，函数式编程可以对程序实现低层次的代码复用。面向对象简化程序的思路是将复杂的部分封装好，以减少出错的
可能。函数式编程时尽量减少出错的地方，从根源减少错误。它能做到这一点实际上就是将 许多 forloop 用内置函数的组合来搞定。比如，将一个列表中不是奇数的数，做平方运算。在函数式编程中就可以利用 filter and map 来搞定。

1.  是否存在用户登录失败的情况？如果出现该情况，程序会如何处理？

很多可能登入失败
账号输入错误，会提示账号不存在
密码输入错误，会提示密码错误。

10.  是否支持多种格式的音乐文件？
在线播放器，没有读取本地音乐的功能
## 社会活动部分

1.  在 Linux 基础课程培训中，你主要教授了哪些内容？
2.  为什么你对 Linux 的基础知识感兴趣？你是怎样学习和掌握这些知识的？
3.  作为南昌大学百年校庆的志愿者，你参与了哪些具体的工作？
4.  你是如何为老师、同学提供技术支持的？遇到了哪些问题，又是如何解决的？
5.  为志愿者，你最大的收获是什么？是否有什么感人的经历或故事作可以分享？
6.  在过去两年的活动中，你是否有感觉到自己的技术能力得到了提升？具体表现在哪些方面？
7.  未来是否还打算继续参加类似的志愿活动？你认为志愿活动对于个人成长和发展的重要性是什么？

gpt 生成的答案

## 第一部分

当然，我很乐意为你回答这些问题：

1. 这个二级流水的 RISC-V CPU 实现了以下功能：支持 R, I, S, B, U, J 六种类型的指令，总共有 35 条指令。

2. 在实现过程中，CPU 被分为了六个子模块，它们是：
   - ALU（算术逻辑单元）：执行算术和逻辑操作。
   - RegFile（寄存器文件）：用于存储和读取寄存器中的数据。
   - Save & Load（存储和加载）：处理存储和加载指令。
   - Imm-Gen（立即数生成器）：生成指令中的立即数。
   - Data Path（数据通路）：负责指令的数据传输和处理。
   - Control Logic（控制逻辑）：根据指令类型和控制信号来控制 CPU 的操作。

3. 在实现前三个模块后，进行了单元测试。单元测试是针对每个模块独立进行的测试，验证其功能是否正确。测试方法可能包括输入特定数据或指令，然后检查输出是否符合预期。测试结果应该表明每个模块的功能是否按预期工作。

4. 在搭建数据通路、控制逻辑和立即数生成器时，选择从最简单的 I 型指令开始构建是因为这些指令相对简单，容易实现和测试。通过逐步增加指令的复杂性，可以逐步扩展到其他类型的指令。

5. 集成测试是指将所有模块组合在一起进行整体测试，以确保它们能够正确地协同工作。在测试过程中可能会遇到一些挑战，例如模块之间的数据传输和控制信号的协调。为了解决这些问题，可以逐步调试和修改模块，确保整个 CPU 的功能正常运行。

6. 流水线设计将 CPU 的运行过程分为两个阶段：取指令（IF）和指令执行（EX）。在这两个阶段之间，使用寄存器来保存程序计数器（PC）和对应的指令（INS）。这样，IF 和 EX 阶段具有不同的 PC 和 INS 值。流水线设计可以提高指令的并行执行效率。

7. 为了解决条件转移指令带来的控制冒险，可以通过控制信号 PCsel 来判断是否需要跳转。如果需要跳转，可以插入一条无操作指令（nop）来消除冒险。这样，在跳转发生时，流水线会正常地执行 nop 指令，保证程序执行的正确性。

## 第二部分

当然，请允许我为您解答这些问题：

1. 为 XV6 增加的 backtrace 系统调用能够追踪一个系统调用函数在运行过程中的调用情况，提升调试效率。通过调用 backtrace，您可以获取函数调用栈的信息，了解函数是如何被调用的。sysinfo 系统调用能在终端上打印出系统目前可用的内存大小和正在运行的 CPU 核心数量，从而实时监控系统的运行情况。

2. 实现页表的访问检测功能时，可以通过给定起始和终止地址来追踪访问过的页表。在访问页表时，XV6记录哪些页表项被读取或写入，并根据访问情况生成相应的访问信息。这些信息可以为垃圾回收器提供参考，帮助识别哪些页表项是活跃的，从而提升系统运行的效率。

3. 页表的访问信息可以为垃圾回收器提供一个良好的参考。通过分析页表的访问模式，垃圾回收器可以确定哪些页表项是被频繁访问的，哪些页表项可能是冗余的或者已经不再需要的。根据这些信息，垃圾回收器可以更有效地管理内存资源，减少内存碎片和提升系统性能。

4. 通过为 XV6 添加一个时钟中断，您可以为一个进程设置中断，并在一定的时钟周期后自动中断运行的进程。当中断发生时，XV6可以在终端上打印出进程占用资源的情况，例如CPU占用率、内存使用情况等。这样，您可以实时监控和分析进程的性能特征，并进行调试和优化。通过恢复之前的进程执行，您可以逐个检查和优化计算密集型程序的性能瓶颈。

5. 在增强 XV6 操作系统的过程中，您可能会面临一些挑战，例如理解并修改现有的源代码、处理操作系统内部的复杂逻辑、确保新功能的正确性和性能优化的有效性等。为了解决这些挑战，您可能需要深入研究 XV6 源码和官方手册，与操作系统领域的相关知识保持同步，并进行系统级调试和性能分析。

6. 通过实现这些新功能和性能优化，您将获得操作系统的深入理解，包括系统调用的设计和实现、内存管理和垃圾回收机制、中断处理和性能调优

## 第三部分

无

## 第四部分

无


